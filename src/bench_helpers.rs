use std::env;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Result;
use num_traits::CheckedSub;
use rand::distr::Alphanumeric;
use rand::distr::SampleString;
use rand::Rng;
use tokio::sync::mpsc;

use crate::api::export::GlobalStateLock;
use crate::api::export::NativeCurrencyAmount;
use crate::api::export::NeptuneProof;
use crate::api::export::Network;
use crate::api::export::ReceivingAddress;
use crate::api::export::Timestamp;
use crate::api::export::Transaction;
use crate::api::export::TransactionDetails;
use crate::api::export::TransactionProof;
use crate::api::export::TxInput;
use crate::config_models::cli_args;
use crate::config_models::data_directory::DataDirectory;
use crate::models::blockchain::block::block_transaction::BlockTransaction;
use crate::models::blockchain::block::validity::block_primitive_witness::BlockPrimitiveWitness;
use crate::models::blockchain::block::validity::block_proof_witness::BlockProofWitness;
use crate::models::blockchain::block::Block;
use crate::models::blockchain::block::BlockProof;
use crate::models::blockchain::transaction::primitive_witness::PrimitiveWitness;
use crate::models::blockchain::transaction::transaction_kernel::TransactionKernelModifier;
use crate::models::channel::RPCServerToMain;
use crate::models::state::wallet::transaction_output::TxOutput;
use crate::models::state::wallet::wallet_configuration::WalletConfiguration;
use crate::models::state::wallet::wallet_entropy::WalletEntropy;
use crate::models::state::wallet::wallet_state::WalletState;
use crate::models::state::GlobalState;
use crate::RPC_CHANNEL_CAPACITY;

/// Data directory used for files generated by benchmarks. All contents of this
/// directory can safely be deleted after each benchmark run.
pub fn benchmark_data_directory(network: Network) -> Result<DataDirectory> {
    let mut rng = rand::rng();
    let user = env::var("USER").unwrap_or_else(|_| "default".to_string());
    let tmp_root: PathBuf = env::temp_dir()
        .join(format!("neptune-benchmark-runs-{}", user))
        .join(Path::new(&Alphanumeric.sample_string(&mut rng, 16)));

    DataDirectory::get(Some(tmp_root), network)
}

/// Initialize a global state with a non-zero balance at genesis.
pub async fn devops_global_state_genesis(network: Network) -> GlobalStateLock {
    let data_directory = benchmark_data_directory(network).unwrap();
    let genesis = Block::genesis(network);
    let cli = cli_args::Args {
        network,
        ..Default::default()
    };
    let wallet_state = devops_wallet_state_genesis(network).await;
    let gs = GlobalState::try_new_with_wallet_state(data_directory, genesis, cli, wallet_state)
        .await
        .unwrap();
    let (rpc_server_to_main_tx, _rpc_server_to_main_rx) =
        mpsc::channel::<RPCServerToMain>(RPC_CHANNEL_CAPACITY);
    GlobalStateLock::from_global_state(gs, rpc_server_to_main_tx)
}

/// Wallet state synced to the genesis block for the specified network.
pub async fn devops_wallet_state_genesis(network: Network) -> WalletState {
    let data_directory = benchmark_data_directory(network).unwrap();
    DataDirectory::create_dir_if_not_exists(&data_directory.root_dir_path())
        .await
        .unwrap();

    DataDirectory::create_dir_if_not_exists(&data_directory.wallet_directory_path())
        .await
        .unwrap();
    let cli_args = cli_args::Args {
        network,
        ..Default::default()
    };
    let configuration = WalletConfiguration::new(&data_directory).absorb_options(&cli_args);

    let genesis = Block::genesis(network);
    WalletState::try_new(configuration, WalletEntropy::devnet_wallet(), &genesis)
        .await
        .unwrap()
}

/// Sends the wallet's entire balance to the provided address. Divides the
/// transaction up into `N` outputs, guaranteeing that the entire available
/// balance is being spent.
pub async fn next_block_incoming_utxos(
    parent: &Block,
    recipient: ReceivingAddress,
    num_outputs: usize,
    sender: &WalletState,
    timestamp: Timestamp,
    network: Network,
) -> Block {
    let one_nau = NativeCurrencyAmount::from_nau(1);

    let fee = one_nau;

    // create N outputs of 1 nau each

    let mut outputs = vec![(recipient.clone(), one_nau); num_outputs - 1];

    // calc remaining amount and add it to outputs
    let intermediate_spend = outputs
        .iter()
        .map(|(_, amt)| *amt)
        .sum::<NativeCurrencyAmount>()
        + fee;

    let msa = parent.mutator_set_accumulator_after().unwrap();
    let wallet_status = sender.get_wallet_status(parent.hash(), &msa).await;
    let available_balance = wallet_status.synced_unspent_available_amount(timestamp);
    let change_amt = available_balance.checked_sub(&intermediate_spend).unwrap();

    outputs.push((recipient.clone(), change_amt));

    let mut input_funds: Vec<TxInput> = vec![];
    for input in sender.spendable_inputs(wallet_status, timestamp) {
        input_funds.push(input);
    }

    let mut rng = rand::rng();
    let outputs = outputs.into_iter().map(|(receiver, amount)| {
        TxOutput::onchain_native_currency_as_change(amount, rng.random(), receiver)
    });
    let tx_details = TransactionDetails::new_without_coinbase(
        input_funds,
        outputs,
        fee,
        timestamp,
        msa,
        network,
    );

    let kernel = PrimitiveWitness::from_transaction_details(&tx_details).kernel;
    let kernel = TransactionKernelModifier::default()
        .merge_bit(true)
        .modify(kernel);

    let tx = Transaction {
        kernel,
        proof: TransactionProof::SingleProof(NeptuneProof::invalid()),
    };
    let tx: BlockTransaction = tx.try_into().unwrap();

    let block_primitive_witness = BlockPrimitiveWitness::new(parent.to_owned(), tx, network);
    let body = block_primitive_witness.body().to_owned();
    let header = block_primitive_witness.header(timestamp, network.target_block_interval());
    let (appendix, proof) = {
        let block_proof_witness = BlockProofWitness::produce(block_primitive_witness);
        let appendix = block_proof_witness.appendix();
        let invalid_proof = NeptuneProof::invalid();
        (appendix, BlockProof::SingleProof(invalid_proof))
    };

    Block::new(header, body, appendix, proof)
}

use twenty_first::math::tip5::Digest;

use super::expected_utxo::ExpectedUtxo;
use super::monitored_utxo::MonitoredUtxo;
use super::sent_transaction::SentTransaction;
use crate::database::storage::storage_schema::traits::*;
use crate::database::storage::storage_schema::DbtSingleton;
use crate::database::storage::storage_schema::DbtVec;
use crate::database::storage::storage_schema::RustyKey;
use crate::database::storage::storage_schema::RustyValue;
use crate::database::storage::storage_schema::SimpleRustyStorage;
use crate::database::NeptuneLevelDb;
use crate::prelude::twenty_first;

pub struct RustyWalletDatabase {
    storage: SimpleRustyStorage,

    // list of utxos we have already received in a block
    monitored_utxos: DbtVec<MonitoredUtxo>,

    // list of off-chain utxos we are expecting to receive in a future block
    expected_utxos: DbtVec<ExpectedUtxo>,

    // records which block the database is synced to
    sync_label: DbtSingleton<Digest>,

    // counts the number of output UTXOs generated by this wallet
    counter: DbtSingleton<u64>,

    // counts derived generation keys
    // The counter value represents derive index of next unused key.
    generation_key_counter: DbtSingleton<u64>,

    // counts derived symmetric keys
    // The counter value represents derive index of next unused key.
    symmetric_key_counter: DbtSingleton<u64>,

    /// list of pre-images to guesser digests in blocks we found. Allows wallet
    /// to spend guesser-fee UTXOs.
    guesser_preimages: DbtVec<Digest>,

    /// list of transactions sent by this wallet.
    sent_transactions: DbtVec<SentTransaction>,
}

impl RustyWalletDatabase {
    pub async fn connect(db: NeptuneLevelDb<RustyKey, RustyValue>) -> Self {
        let mut storage = SimpleRustyStorage::new_with_callback(
            db,
            "RustyWalletDatabase-Schema",
            crate::LOG_TOKIO_LOCK_EVENT_CB,
        );

        let monitored_utxos = storage
            .schema
            .new_vec::<MonitoredUtxo>("monitored_utxos")
            .await;

        let expected_utxos = storage
            .schema
            .new_vec::<ExpectedUtxo>("expected_utxos")
            .await;

        let sent_transactions = storage
            .schema
            .new_vec::<SentTransaction>("sent_transactions")
            .await;

        let sync_label = storage.schema.new_singleton::<Digest>("sync_label").await;
        let counter = storage.schema.new_singleton::<u64>("counter").await;

        let generation_key_counter = storage
            .schema
            .new_singleton::<u64>("generation_key_counter")
            .await;
        let symmetric_key_counter = storage
            .schema
            .new_singleton::<u64>("symmetric_key_counter")
            .await;

        let guesser_preimages = storage.schema.new_vec::<Digest>("guesser_preimages").await;

        Self {
            storage,
            monitored_utxos,
            expected_utxos,
            sent_transactions,
            sync_label,
            counter,
            generation_key_counter,
            symmetric_key_counter,
            guesser_preimages,
        }
    }

    /// get monitored_utxos.
    pub fn monitored_utxos(&self) -> &DbtVec<MonitoredUtxo> {
        &self.monitored_utxos
    }

    /// get mutable monitored_utxos.
    pub fn monitored_utxos_mut(&mut self) -> &mut DbtVec<MonitoredUtxo> {
        &mut self.monitored_utxos
    }

    /// get expected_utxos.
    pub fn expected_utxos(&self) -> &DbtVec<ExpectedUtxo> {
        &self.expected_utxos
    }

    /// get mutable expected_utxos.
    pub fn expected_utxos_mut(&mut self) -> &mut DbtVec<ExpectedUtxo> {
        &mut self.expected_utxos
    }

    /// get sent transactions
    pub fn sent_transactions(&self) -> &DbtVec<SentTransaction> {
        &self.sent_transactions
    }

    /// get mutable sent transactions
    pub fn sent_transactions_mut(&mut self) -> &mut DbtVec<SentTransaction> {
        &mut self.sent_transactions
    }

    pub fn guesser_preimages(&self) -> &DbtVec<Digest> {
        &self.guesser_preimages
    }

    pub fn guesser_preimages_mut(&mut self) -> &mut DbtVec<Digest> {
        &mut self.guesser_preimages
    }

    /// Get the hash of the block to which this database is synced.
    pub async fn get_sync_label(&self) -> Digest {
        self.sync_label.get().await
    }

    pub async fn set_sync_label(&mut self, sync_label: Digest) {
        self.sync_label.set(sync_label).await;
    }

    pub async fn get_counter(&self) -> u64 {
        self.counter.get().await
    }

    pub async fn set_counter(&mut self, counter: u64) {
        self.counter.set(counter).await;
    }

    /// retrieve wallet derivation counter for generation keys
    pub async fn get_generation_key_counter(&self) -> u64 {
        self.generation_key_counter.get().await
    }

    /// set wallet derivation counter for generation keys
    pub async fn set_generation_key_counter(&mut self, counter: u64) {
        self.generation_key_counter.set(counter).await;
    }

    /// retrieve wallet derivation counter for symmetric keys
    pub async fn get_symmetric_key_counter(&self) -> u64 {
        self.symmetric_key_counter.get().await
    }

    /// set wallet derivation counter for symmetric keys
    pub async fn set_symmetric_key_counter(&mut self, counter: u64) {
        self.symmetric_key_counter.set(counter).await;
    }
}

impl StorageWriter for RustyWalletDatabase {
    async fn persist(&mut self) {
        self.storage.persist().await
    }

    async fn drop_unpersisted(&mut self) {
        unimplemented!("wallet does not need it")
    }
}

use core::num;
use std::cmp::Ordering;
use std::path::Path;

use futures::future::Either;
use futures::pin_mut;
use futures::stream;
use futures::Stream;
use futures::StreamExt;
use leveldb::db;
use serde::Deserialize;
use serde::Serialize;
use tasm_lib::prelude::Tip5;
use tasm_lib::twenty_first::tip5::digest::Digest;

use super::expected_utxo::ExpectedUtxo;
use super::migrate_db;
use super::monitored_utxo::MonitoredUtxo;
use super::sent_transaction::SentTransaction;
use super::wallet_db_tables::WalletDbTables;
use super::wallet_db_tables::WALLET_DB_SCHEMA_VERSION;
use crate::api::export::AdditionRecord;
use crate::api::export::BlockHeight;
use crate::api::export::Timestamp;
use crate::application::database::storage::storage_schema::traits::*;
use crate::application::database::storage::storage_schema::DbtMap;
use crate::application::database::storage::storage_schema::DbtVec;
use crate::application::database::storage::storage_schema::RustyKey;
use crate::application::database::storage::storage_schema::RustyValue;
use crate::application::database::storage::storage_schema::SimpleRustyStorage;
use crate::application::database::storage::storage_vec::Index;
use crate::application::database::NeptuneLevelDb;
use crate::state::wallet::wallet_db_tables::StrongUtxoKey;
use crate::util_types::mutator_set::ms_membership_proof::MsMembershipProof;
use crate::util_types::mutator_set::removal_record::absolute_index_set::AbsoluteIndexSet;

const WALLET_SCHEMA_VERSION: u16 = 3;

#[derive(Debug, Copy, Clone, Serialize, Deserialize)]
enum WalletDbKey {
    /// Number of monitored UTXOs managed by this wallet.
    NumMonitoredUtxos,

    /// Append-only list of utxos we have already received in a block.
    /// Each element in this list must be accompanied by an element in the
    /// value [`Self::StrongKeyToMonitoredUtxo`] such that duplicate UTXOs are
    /// never added and this check can be performed fast. And it must be
    /// accompanied by an element in the [`Self::IndexSetDigestToMonitoredUtxo`]
    /// table for fast mapping of absolute index set to monitored UTXO, such
    /// that spent UTXOs can/ quickly be identified.
    MonitoredUtxoByIndex(u64),

    /// Index for fast lookup of monitored UTXO, by (addition record, AOCL leaf
    /// index) pair.
    StrongKeyToMonitoredUtxo(StrongUtxoKey),

    /// Index for fast lookup of monitored UTXO, by removal record.
    IndexSetDigestToMonitoredUtxo(Digest),

    /// Number of expected UTXOs known by this wallet.
    NumExpectedUtxos,

    /// list of off-chain utxos we are expecting to receive in a future block.
    /// Indexed by [`Self::AdditionRecordToExpectedUtxo`].
    ExpectedUtxoByIndex(u64),

    /// Index for fast lookup of expected UTXOs.
    AdditionRecordToExpectedUtxo(AdditionRecord),

    /// The number of transactions *initiated* by this wallet.
    NumSentTransactions,

    /// Transactions *initiated* by this wallet.  There is no guarantee that the
    /// initiated transactions have been mined.
    SentTransactionByIndex(u64),

    /// Records which block the database is synced to, the hash of latest
    /// applied block.
    SyncLabel,

    /// counts the number of output UTXOs generated by this wallet
    NumOutputUtxos,

    /// counts derived generation keys
    GenerationKeyCounter,

    /// counts derived symmetric keys
    SymmetricKeyCounter,

    /// schema version for backwards upgrade compatibility.
    SchemaVersion,
}

/// The values used by the UTXO index database.
///
/// See documentstion in [`WalletDbKey`] for each variant of this enum.
#[derive(Debug, Clone, Serialize, Deserialize)]
enum WalletDbValue {
    NumMonitoredUtxos(u64),

    MonitoredUtxoByIndex(MonitoredUtxo),

    StrongKeyToMonitoredUtxo(u64),

    IndexSetDigestToMonitoredUtxo(u64),

    NumExpectedUtxos(u64),

    ExpectedUtxoByIndex(ExpectedUtxo),

    AdditionRecordToExpectedUtxo(u64),

    NumSentTransactions(u64),

    SentTransactionByIndex(SentTransaction),

    SyncLabel(Digest),

    NumOutputUtxos(u64),

    GenerationKeyCounter(u64),

    SymmetricKeyCounter(u64),

    SchemaVersion(u16),
}

impl WalletDbValue {
    fn expect_num_monitored_utxos(self) -> u64 {
        match self {
            WalletDbValue::NumMonitoredUtxos(count) => count,
            _ => panic!("Expected NumMonitoredUtxos found {:?}", self),
        }
    }

    fn expect_monitored_utxo_by_index(self) -> MonitoredUtxo {
        match self {
            WalletDbValue::MonitoredUtxoByIndex(mutxo) => mutxo,
            _ => panic!("Expected MonitoredUtxoByIndex found {:?}", self),
        }
    }

    fn expect_strong_key_to_monitored_utxo(self) -> u64 {
        match self {
            WalletDbValue::StrongKeyToMonitoredUtxo(index) => index,
            _ => panic!("Expected StrongKeyToMonitoredUtxo found {:?}", self),
        }
    }

    fn expect_index_set_digest_to_monitored_utxo(self) -> u64 {
        match self {
            WalletDbValue::IndexSetDigestToMonitoredUtxo(index) => index,
            _ => panic!("Expected IndexSetDigestToMonitoredUtxo found {:?}", self),
        }
    }

    fn expect_num_expected_utxos(self) -> u64 {
        match self {
            WalletDbValue::NumExpectedUtxos(count) => count,
            _ => panic!("Expected NumExpectedUtxos found {:?}", self),
        }
    }

    fn expect_expected_utxo_by_index(self) -> ExpectedUtxo {
        match self {
            WalletDbValue::ExpectedUtxoByIndex(eutxo) => eutxo,
            _ => panic!("Expected ExpectedUtxoByIndex found {:?}", self),
        }
    }

    fn expect_addition_record_to_expected_utxo(self) -> u64 {
        match self {
            WalletDbValue::AdditionRecordToExpectedUtxo(index) => index,
            _ => panic!("Expected AdditionRecordToExpectedUtxo found {:?}", self),
        }
    }

    fn expect_num_sent_transactions(self) -> u64 {
        match self {
            WalletDbValue::NumSentTransactions(count) => count,
            _ => panic!("Expected NumSentTransactions found {:?}", self),
        }
    }

    fn expect_sent_transaction_by_index(self) -> SentTransaction {
        match self {
            WalletDbValue::SentTransactionByIndex(tx) => tx,
            _ => panic!("Expected SentTransactionByIndex found {:?}", self),
        }
    }

    fn expect_sync_label(self) -> Digest {
        match self {
            WalletDbValue::SyncLabel(digest) => digest,
            _ => panic!("Expected SyncLabel found {:?}", self),
        }
    }

    fn expect_num_output_utxos(self) -> u64 {
        match self {
            WalletDbValue::NumOutputUtxos(count) => count,
            _ => panic!("Expected NumOutputUtxos found {:?}", self),
        }
    }

    fn expect_generation_key_counter(self) -> u64 {
        match self {
            WalletDbValue::GenerationKeyCounter(count) => count,
            _ => panic!("Expected GenerationKeyCounter found {:?}", self),
        }
    }

    fn expect_symmetric_key_counter(self) -> u64 {
        match self {
            WalletDbValue::SymmetricKeyCounter(count) => count,
            _ => panic!("Expected SymmetricKeyCounter found {:?}", self),
        }
    }

    fn expect_schema_version(self) -> u16 {
        match self {
            WalletDbValue::SchemaVersion(version) => version,
            _ => panic!("Expected SchemaVersion found {:?}", self),
        }
    }
}

#[derive(Debug)]
pub struct RustyWalletDatabase {
    db: NeptuneLevelDb<WalletDbKey, WalletDbValue>,
}

/// Communicates whether the monitored UTXO inserted was already known to the database, or whether
/// it was new.
#[derive(Debug, Clone, Copy)]
pub(crate) enum MonitoredUtxoInsertResult {
    /// Indicates that the inserted monitored UTXO was new; not previously known to the wallet
    /// database. The returned index is the list index at which the monitored UTXO was inserted.
    New(Index),

    /// The monitored UTXO was already tracked by the wallet database. The returned index is the
    /// list index into the list of monitored UTXOs.
    Existing(Index),
}

impl RustyWalletDatabase {
    async fn open_wallet_db_new(
        path: &Path,
    ) -> anyhow::Result<NeptuneLevelDb<WalletDbKey, WalletDbValue>> {
        NeptuneLevelDb::new(path, &crate::application::database::create_db_if_missing())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to open wallet db at '{}': {}", path.display(), e))
    }

    async fn open_wallet_db_old(
        path: &Path,
    ) -> anyhow::Result<NeptuneLevelDb<RustyKey, RustyValue>> {
        NeptuneLevelDb::new(path, &crate::application::database::create_db_if_missing())
            .await
            .map_err(|e| anyhow::anyhow!("Failed to open wallet db at '{}': {}", path.display(), e))
    }

    /// try to connect to db and fail if schema requires migration
    pub async fn try_connect(path: &Path) -> Result<Self, WalletDbConnectError> {
        Self::try_connect_internal(path, false).await
    }

    /// try to connect to db and migrate schema if required
    pub async fn try_connect_and_migrate(path: &Path) -> Result<Self, WalletDbConnectError> {
        Self::try_connect_internal(path, true).await
    }

    async fn try_connect_internal(
        path: &Path,
        migrate: bool,
    ) -> Result<Self, WalletDbConnectError> {
        async fn is_new_schema(path: &Path) -> bool {
            // db.get(WalletDbKey::SchemaVersion).await.is_some()
            //     && db.get(WalletDbKey::NumMonitoredUtxos).await.is_some()
            //     && db.get(WalletDbKey::SyncLabel).await.is_some()
            // TODO: Fix this. How do we implement this check? The correct thing
            // to do is to check for the *absence* of keys that are present in
            // the old schema. Maybe change function arguments?
            true
        }

        let (schema_version, sync_label) = if is_new_schema(&path).await {
            let db_new = RustyWalletDatabase::open_wallet_db_new(path).await?;
            let schema_version = db_new
                .get(WalletDbKey::SchemaVersion)
                .await
                .unwrap_or(WalletDbValue::SchemaVersion(0))
                .expect_schema_version();
            let sync_label = db_new
                .get(WalletDbKey::SyncLabel)
                .await
                .unwrap_or(WalletDbValue::SyncLabel(Digest::default()))
                .expect_sync_label();
            (schema_version, sync_label)
        } else {
            let db = RustyWalletDatabase::open_wallet_db_old(path).await?;
            let mut storage = SimpleRustyStorage::new_with_callback(
                db,
                "RustyWalletDatabase-Schema",
                crate::LOG_TOKIO_LOCK_EVENT_CB,
            );
            let mut tables = WalletDbTables::load_schema_in_order(&mut storage).await;
            let schema_version = tables.schema_version.get();
            let sync_label = tables.sync_label.get();
            (schema_version, sync_label)
        };

        tracing::trace!("Read wallet database schema version: {schema_version}");
        tracing::trace!("Read sync_label: {sync_label:x}");

        // if the DB is brand-new then we set the schema version to the most
        // recent value, since there's nothing to migrate. The wallet database
        // only considered new if schema_version *and* sync_label have default
        // values since some wallet-DBs might have been populated without the
        // sync label being set, because of recovery functions' past behavior.
        let is_new_db = schema_version == 0 && sync_label == Digest::default();
        if is_new_db {
            let mut db = RustyWalletDatabase::open_wallet_db_new(path).await?;
            db.put(
                WalletDbKey::SchemaVersion,
                WalletDbValue::SchemaVersion(WALLET_SCHEMA_VERSION),
            )
            .await;
            db.flush().await;
            tracing::info!(
                "set new wallet database to schema version: v{}",
                WALLET_SCHEMA_VERSION
            );
        } else {
            tracing::debug!("Wallet DB schema version is {}", schema_version);

            match schema_version.cmp(&WALLET_SCHEMA_VERSION) {
                // happy path. db schema version matches code schema version.
                Ordering::Equal => {
                    tracing::info!(
                        "Wallet DB schema version {} is correct.  proceeding",
                        schema_version
                    );
                }

                // database has old schema version and needs to be migrated.
                Ordering::Less => {
                    todo!("Implement migration of wallet database schema from version {schema_version} to {WALLET_SCHEMA_VERSION}");
                    // if migrate {
                    //     migrate_db::migrate_range(
                    //         &mut storage,
                    //         schema_version,
                    //         WALLET_SCHEMA_VERSION,
                    //     )
                    //     .await?;

                    //     // Reload table data after migration to get rid of
                    //     // potential ephemeral (non-persisted) data such as
                    //     // vector length, in case the migration changed any
                    //     // vector lengths, e.g. due to deduplication.
                    //     storage.reset_schema();
                    //     tables = WalletDbTables::load_schema_in_order(&mut storage).await;
                    // } else {
                    //     return Err(WalletDbConnectError::SchemaVersionTooLow {
                    //         found: schema_version,
                    //         expected: WALLET_SCHEMA_VERSION,
                    //     });
                    // }
                }

                // database is too new, probably from a newer neptune-core binary.
                Ordering::Greater => {
                    return Err(WalletDbConnectError::SchemaVersionTooHigh {
                        found: schema_version,
                        expected: WALLET_SCHEMA_VERSION,
                    });
                }
            }
        }

        Ok(Self {
            db: RustyWalletDatabase::open_wallet_db_new(path).await?,
        })
    }

    /// Return the list index of the monitored UTXO matching the specified
    /// absolute index set digest, if any.
    pub(crate) async fn index_set_to_mutxo(&self, index_set_digest: Digest) -> Option<Index> {
        self.db
            .get(WalletDbKey::IndexSetDigestToMonitoredUtxo(index_set_digest))
            .await
            .map(|value| value.expect_index_set_digest_to_monitored_utxo())
    }

    pub(crate) async fn stream_monitored_utxos(
        &self,
        reverse_order: bool,
    ) -> impl Stream<Item = (Index, MonitoredUtxo)> + '_ {
        let num_mutxos = self
            .db
            .get(WalletDbKey::NumMonitoredUtxos)
            .await
            .unwrap_or(WalletDbValue::NumMonitoredUtxos(0))
            .expect_num_monitored_utxos();

        let stream = if reverse_order {
            Either::Left(futures::stream::iter((0..num_mutxos).rev()))
        } else {
            Either::Right(futures::stream::iter(0..num_mutxos))
        };

        stream.then(move |index| async move {
            let mutxo = self
                .db
                .get(WalletDbKey::MonitoredUtxoByIndex(index))
                .await
                .expect("Indexed monitored UTXO must be present in database")
                .expect_monitored_utxo_by_index();
            (index, mutxo)
        })
    }

    pub(crate) async fn num_monitored_utxos(&self) -> u64 {
        self.db
            .get(WalletDbKey::NumMonitoredUtxos)
            .await
            .unwrap_or(WalletDbValue::NumMonitoredUtxos(0))
            .expect_num_monitored_utxos()
    }

    /// Convenience method for loading all expected UTXOs into memory.
    pub(crate) async fn all_monitored_utxos(&self) -> Vec<MonitoredUtxo> {
        let num_monitored_utxos = self.num_monitored_utxos().await;
        let mut monitored_utxos = Vec::with_capacity(num_monitored_utxos as usize);
        for i in 0..num_monitored_utxos {
            let monitored_utxo = self
                .db
                .get(WalletDbKey::MonitoredUtxoByIndex(i))
                .await
                .expect("Value must be present since index is smaller than the length")
                .expect_monitored_utxo_by_index();
            monitored_utxos.push(monitored_utxo);
        }
        monitored_utxos
    }

    /// Return existing monitored UTXO by list index in the list of all
    /// monitored UTXOs.
    ///
    /// # Panics
    ///
    /// - If index for monitored UTXO is out of range.
    #[inline(always)]
    pub(crate) async fn monitored_utxo_by_list_index(&self, index: Index) -> MonitoredUtxo {
        let key = WalletDbKey::MonitoredUtxoByIndex(index);
        self.db
            .get(key)
            .await
            .expect("Could not find monitored UTXO number {index} in wallet database")
            .expect_monitored_utxo_by_index()
    }

    /// Return the UTXO of a monitored UTXO and the monitored UTXOs list index
    /// matching the specified absolute index set, if any.
    ///
    /// # Panics
    ///
    /// - If index for monitored UTXO is out of range, which requires the
    ///   database to be malformed, to be missing a monitored UTXO element
    ///   although the lookup table points to it.
    pub(crate) async fn monitored_utxo_by_index_set(
        &self,
        index_set: &AbsoluteIndexSet,
    ) -> Option<(MonitoredUtxo, Index)> {
        let index_set_digest = Tip5::hash(index_set);
        let key = WalletDbKey::IndexSetDigestToMonitoredUtxo(index_set_digest);
        let list_index = self
            .db
            .get(key)
            .await?
            .expect_index_set_digest_to_monitored_utxo();

        Some((
            self.monitored_utxo_by_list_index(list_index).await,
            list_index,
        ))
    }

    /// Mark a monitored UTXO as abandoned
    ///
    /// # Panics
    ///
    /// - If index for monitored UTXO is out of range.
    pub(crate) async fn abandon_monitored_utxo(
        &mut self,
        mutxo_list_index: Index,
        abandoned_at: (Digest, Timestamp, BlockHeight),
    ) {
        let mut existing_mutxo = self.monitored_utxo_by_list_index(mutxo_list_index).await;
        existing_mutxo.abandoned_at = Some(abandoned_at);
        self.db
            .put(
                WalletDbKey::MonitoredUtxoByIndex(mutxo_list_index),
                WalletDbValue::MonitoredUtxoByIndex(existing_mutxo),
            )
            .await;
    }

    /// Mark existing monitored UTXO as received in a specified block.
    ///
    /// # Panics
    ///
    /// - If the [`StrongUtxoKey`] is not known by the wallet.
    pub(crate) async fn update_mutxo_confirmation_block(
        &mut self,
        strong_utxo_key: &StrongUtxoKey,
        block_info: (Digest, Timestamp, BlockHeight),
    ) {
        let list_index = self
            .db
            .get(WalletDbKey::StrongKeyToMonitoredUtxo(*strong_utxo_key))
            .await
            .expect("Expected UTXO key must be present in database")
            .expect_strong_key_to_monitored_utxo();
        let mut existing_mutxo = self.monitored_utxo_by_list_index(list_index).await;
        existing_mutxo.confirmed_in_block = block_info;
        self.db
            .put(
                WalletDbKey::MonitoredUtxoByIndex(list_index),
                WalletDbValue::MonitoredUtxoByIndex(existing_mutxo),
            )
            .await;
    }

    /// Mark a [`MonitoredUtxo`] as spent in a specified block.
    ///
    /// # Panics
    ///
    /// - If index for monitored UTXO is out of range.
    pub(crate) async fn mark_mutxo_as_spent(
        &mut self,
        mutxo_list_index: Index,
        block_hash: Digest,
        block_timestamp: Timestamp,
        block_height: BlockHeight,
    ) {
        let mut spent_mutxo = self.monitored_utxo_by_list_index(mutxo_list_index).await;
        spent_mutxo.mark_as_spent(block_hash, block_timestamp, block_height);
        self.db
            .put(
                WalletDbKey::MonitoredUtxoByIndex(mutxo_list_index),
                WalletDbValue::MonitoredUtxoByIndex(spent_mutxo),
            )
            .await;
    }

    /// Add a new [`MsMembershipProof`] to a [`MonitoredUtxo`].
    ///
    /// # Panics
    ///
    /// - If index for monitored UTXO is out of range.
    pub(crate) async fn add_msmp_to_monitored_utxo(
        &mut self,
        mutxo_list_index: Index,
        block_hash: Digest,
        msmp: MsMembershipProof,
    ) {
        let mut mutxo = self.monitored_utxo_by_list_index(mutxo_list_index).await;
        mutxo.add_membership_proof_for_tip(block_hash, msmp);
        self.db
            .put(
                WalletDbKey::MonitoredUtxoByIndex(mutxo_list_index),
                WalletDbValue::MonitoredUtxoByIndex(mutxo),
            )
            .await;
    }

    /// Check if the wallet database contains a [`MonitoredUtxo`] with the
    /// specified [`StrongUtxoKey`].
    pub(crate) async fn has_mutxo(&self, strong_utxo_key: &StrongUtxoKey) -> bool {
        let key = WalletDbKey::StrongKeyToMonitoredUtxo(*strong_utxo_key);
        self.db.get(key).await.is_some()
    }

    /// Insert a new [`MonitoredUtxo`] into the wallet's database and return the
    /// index of the inserted element, if this monitored UTXO is new. If the
    /// monitored UTXO is already known to the wallet database, the index of the
    /// duplicate (already existing entry) is returned. If the entry already
    /// existed in the database, this call does not write to the database.
    ///
    /// The list of [`MonitoredUtxo`] is only allowed to grow through this
    /// function, since this function handles the lookup tables and the
    /// duplication checks. If the list of [`MonitoredUtxo`] grows in other ways
    /// than through this function, the database indices might become
    /// inconsistent.
    pub(crate) async fn insert_mutxo(
        &mut self,
        monitored_utxo: MonitoredUtxo,
    ) -> MonitoredUtxoInsertResult {
        // Check for duplicated entries
        let strong_key = monitored_utxo.strong_utxo_key();
        if let Some(existing_list_index) = self
            .db
            .get(WalletDbKey::StrongKeyToMonitoredUtxo(strong_key))
            .await
        {
            return MonitoredUtxoInsertResult::Existing(
                existing_list_index.expect_strong_key_to_monitored_utxo(),
            );
        }

        let list_index = self
            .db
            .get(WalletDbKey::NumMonitoredUtxos)
            .await
            .unwrap_or(WalletDbValue::NumMonitoredUtxos(0))
            .expect_num_monitored_utxos();

        // populate lookup table for addition record/AOCL leaf index pair
        self.db
            .put(
                WalletDbKey::StrongKeyToMonitoredUtxo(strong_key),
                WalletDbValue::StrongKeyToMonitoredUtxo(list_index),
            )
            .await;

        // Populate lookup table for index set.
        let index_set_digest = Tip5::hash(&monitored_utxo.absolute_indices());
        self.db
            .put(
                WalletDbKey::IndexSetDigestToMonitoredUtxo(index_set_digest),
                WalletDbValue::IndexSetDigestToMonitoredUtxo(list_index),
            )
            .await;

        // Add monitored UTXO to list
        self.db
            .put(
                WalletDbKey::MonitoredUtxoByIndex(list_index),
                WalletDbValue::MonitoredUtxoByIndex(monitored_utxo),
            )
            .await;

        // Update number of monitored UTXOs
        self.db
            .put(
                WalletDbKey::NumMonitoredUtxos,
                WalletDbValue::NumMonitoredUtxos(list_index + 1),
            )
            .await;

        MonitoredUtxoInsertResult::New(list_index)
    }

    /// Return an [`ExpectedUtxo`] if any with a matching addition record exists.
    pub(crate) async fn expected_utxo_by_addition_record(
        &self,
        addition_record: &AdditionRecord,
    ) -> Option<ExpectedUtxo> {
        let list_index = self
            .db
            .get(WalletDbKey::AdditionRecordToExpectedUtxo(*addition_record))
            .await?
            .expect_addition_record_to_expected_utxo();

        Some(
            self.db
                .get(WalletDbKey::ExpectedUtxoByIndex(list_index))
                .await
                .expect("Indexed expected UTXO must be present in database")
                .expect_expected_utxo_by_index(),
        )
    }

    /// Return all expected UTXOs
    pub(crate) async fn stream_expected_utxos(
        &self,
    ) -> impl Stream<Item = (Index, ExpectedUtxo)> + '_ {
        let num_eutxos = self
            .db
            .get(WalletDbKey::NumExpectedUtxos)
            .await
            .unwrap_or(WalletDbValue::NumExpectedUtxos(0))
            .expect_num_expected_utxos();
        futures::stream::iter(0..num_eutxos).then(move |index| async move {
            let eutxo = self
                .db
                .get(WalletDbKey::ExpectedUtxoByIndex(index))
                .await
                .expect("Indexed expected UTXO must be present in database")
                .expect_expected_utxo_by_index();
            (index, eutxo)
        })
    }

    /// Mark the expected UTXO matching the addition record as received. Does
    /// nothing if an expected UTXO with this addition record does not exist
    /// in the database.
    pub(crate) async fn mark_expected_utxo_as_received(
        &mut self,
        addition_record: &AdditionRecord,
        block_hash: Digest,
        block_timestamp: Timestamp,
    ) {
        let list_index = self
            .db
            .get(WalletDbKey::AdditionRecordToExpectedUtxo(*addition_record))
            .await;

        let Some(list_index) = list_index else {
            return;
        };

        let list_index = list_index.expect_addition_record_to_expected_utxo();

        let mut entry = self
            .db
            .get(WalletDbKey::ExpectedUtxoByIndex(list_index))
            .await
            .expect("Indexed expected UTXO must be present in database")
            .expect_expected_utxo_by_index();

        entry.mined_in_block = Some((block_hash, block_timestamp));

        self.db
            .put(
                WalletDbKey::ExpectedUtxoByIndex(list_index),
                WalletDbValue::ExpectedUtxoByIndex(entry),
            )
            .await;
    }

    /// Insert an expected UTXO into the wallet database. The insertion of a
    /// duplicate is guaranteed to not modify the database. Duplicates are
    /// identified by their addition records. So two expected UTXOs with the
    /// same addition record cannot be added to the wallet database.
    ///
    /// All insertions of [`ExpectedUtxo`]s into the database must go through
    /// this method to ensure indexing consistency.
    pub(crate) async fn insert_expected_utxo(&mut self, expected_utxo: ExpectedUtxo) {
        // Check for duplicated entries
        if self
            .db
            .get(WalletDbKey::AdditionRecordToExpectedUtxo(
                expected_utxo.addition_record,
            ))
            .await
            .is_some()
        {
            return;
        }

        let list_index = self
            .db
            .get(WalletDbKey::NumExpectedUtxos)
            .await
            .unwrap_or(WalletDbValue::NumExpectedUtxos(0))
            .expect_num_expected_utxos();
        self.db
            .put(
                WalletDbKey::AdditionRecordToExpectedUtxo(expected_utxo.addition_record),
                WalletDbValue::AdditionRecordToExpectedUtxo(list_index),
            )
            .await;

        self.db
            .put(
                WalletDbKey::ExpectedUtxoByIndex(list_index),
                WalletDbValue::ExpectedUtxoByIndex(expected_utxo),
            )
            .await;

        self.db
            .put(
                WalletDbKey::NumExpectedUtxos,
                WalletDbValue::NumExpectedUtxos(list_index + 1),
            )
            .await;
    }

    /// Convenience method for loading all expected UTXOs into memory.
    pub(crate) async fn all_expected_utxos(&self) -> Vec<ExpectedUtxo> {
        let num_expected_utxos = self.num_expected_utxos().await;
        let mut expected_utxos = Vec::with_capacity(num_expected_utxos as usize);
        for i in 0..num_expected_utxos {
            let expected_utxo = self
                .db
                .get(WalletDbKey::ExpectedUtxoByIndex(i))
                .await
                .expect("Value must be present since index is smaller than the length")
                .expect_expected_utxo_by_index();
            expected_utxos.push(expected_utxo);
        }
        expected_utxos
    }

    /// Return the number of expected UTXOs in the database.
    pub(crate) async fn num_expected_utxos(&self) -> u64 {
        self.db
            .get(WalletDbKey::NumExpectedUtxos)
            .await
            .unwrap_or(WalletDbValue::NumExpectedUtxos(0))
            .expect_num_expected_utxos()
    }

    /// Delete all expected UTXOs and associated indexing data from the
    /// database.
    pub(crate) async fn clear_expected_utxos(&mut self) {
        let num_expected_utxos = self.num_expected_utxos().await;
        for i in 0..num_expected_utxos {
            let eutxo = self
                .db
                .get(WalletDbKey::ExpectedUtxoByIndex(i))
                .await
                .expect("Value must be present since index is smaller than the length")
                .expect_expected_utxo_by_index();
            self.db.delete(WalletDbKey::ExpectedUtxoByIndex(i)).await;
            self.db
                .delete(WalletDbKey::AdditionRecordToExpectedUtxo(
                    eutxo.addition_record,
                ))
                .await;
        }
        self.db
            .put(
                WalletDbKey::NumExpectedUtxos,
                WalletDbValue::NumExpectedUtxos(0),
            )
            .await;
    }

    pub(crate) async fn add_sent_transaction(&mut self, sent_transaction: SentTransaction) {
        let list_index = self
            .db
            .get(WalletDbKey::NumSentTransactions)
            .await
            .unwrap_or(WalletDbValue::NumSentTransactions(0))
            .expect_num_sent_transactions();
        self.db
            .put(
                WalletDbKey::SentTransactionByIndex(list_index),
                WalletDbValue::SentTransactionByIndex(sent_transaction),
            )
            .await;
        self.db
            .put(
                WalletDbKey::NumSentTransactions,
                WalletDbValue::NumSentTransactions(list_index + 1),
            )
            .await;
    }

    pub(crate) async fn stream_sent_transactions(
        &self,
        reverse_order: bool,
    ) -> impl Stream<Item = SentTransaction> + '_ {
        let num_sent_transactions = self
            .db
            .get(WalletDbKey::NumSentTransactions)
            .await
            .unwrap_or(WalletDbValue::NumSentTransactions(0))
            .expect_num_sent_transactions();

        let stream = if reverse_order {
            Either::Left(futures::stream::iter((0..num_sent_transactions).rev()))
        } else {
            Either::Right(futures::stream::iter(0..num_sent_transactions))
        };
        stream.then(move |index| async move {
            let sent_transaction = self
                .db
                .get(WalletDbKey::SentTransactionByIndex(index))
                .await
                .expect("Indexed sent transaction must be present in database")
                .expect_sent_transaction_by_index();
            sent_transaction
        })
    }

    /// Get the hash of the block to which this database is synced.
    pub async fn get_sync_label(&self) -> Digest {
        self.db
            .get(WalletDbKey::SyncLabel)
            .await
            .unwrap_or(WalletDbValue::SyncLabel(Digest::default()))
            .expect_sync_label()
    }

    pub async fn set_sync_label(&mut self, sync_label: Digest) {
        self.db
            .put(WalletDbKey::SyncLabel, WalletDbValue::SyncLabel(sync_label))
            .await;
    }

    pub async fn get_counter(&self) -> u64 {
        self.db
            .get(WalletDbKey::NumOutputUtxos)
            .await
            .unwrap_or(WalletDbValue::NumOutputUtxos(0))
            .expect_num_output_utxos()
    }

    pub async fn set_counter(&mut self, counter: u64) {
        self.db
            .put(
                WalletDbKey::NumOutputUtxos,
                WalletDbValue::NumOutputUtxos(counter),
            )
            .await;
    }

    /// retrieve wallet derivation counter for generation keys
    pub async fn get_generation_key_counter(&self) -> u64 {
        self.db
            .get(WalletDbKey::GenerationKeyCounter)
            .await
            .unwrap_or(WalletDbValue::GenerationKeyCounter(0))
            .expect_generation_key_counter()
    }

    /// set wallet derivation counter for generation keys
    pub async fn set_generation_key_counter(&mut self, counter: u64) {
        self.db
            .put(
                WalletDbKey::GenerationKeyCounter,
                WalletDbValue::GenerationKeyCounter(counter),
            )
            .await;
    }

    /// retrieve wallet derivation counter for symmetric keys
    pub async fn get_symmetric_key_counter(&self) -> u64 {
        self.db
            .get(WalletDbKey::SymmetricKeyCounter)
            .await
            .unwrap_or(WalletDbValue::SymmetricKeyCounter(0))
            .expect_symmetric_key_counter()
    }

    /// set wallet derivation counter for symmetric keys
    pub async fn set_symmetric_key_counter(&mut self, counter: u64) {
        self.db
            .put(
                WalletDbKey::SymmetricKeyCounter,
                WalletDbValue::SymmetricKeyCounter(counter),
            )
            .await;
    }

    /// retrieve the database schema version
    pub async fn schema_version(&self) -> u16 {
        self.db
            .get(WalletDbKey::SchemaVersion)
            .await
            .unwrap_or(WalletDbValue::SchemaVersion(WALLET_SCHEMA_VERSION))
            .expect_schema_version()
    }

    #[doc(hidden)]
    /// Delete all monitored UTXOs and associated lookup tables.
    /// This function is required for benchmarks, but is not part of the public
    /// API.
    pub async fn clear_mutxos(&mut self) {
        let num_monitored_utxos = self.num_monitored_utxos().await;
        for i in 0..num_monitored_utxos {
            let mutxo = self
                .db
                .get(WalletDbKey::MonitoredUtxoByIndex(i))
                .await
                .expect("Value must be present since index is smaller than the length")
                .expect_monitored_utxo_by_index();
            self.db
                .delete(WalletDbKey::StrongKeyToMonitoredUtxo(
                    mutxo.strong_utxo_key(),
                ))
                .await;
            let index_set_digest = Tip5::hash(&mutxo.absolute_indices());
            self.db
                .delete(WalletDbKey::IndexSetDigestToMonitoredUtxo(index_set_digest))
                .await;
            self.db.delete(WalletDbKey::MonitoredUtxoByIndex(i)).await;
        }
        self.db
            .put(
                WalletDbKey::NumMonitoredUtxos,
                WalletDbValue::NumMonitoredUtxos(0),
            )
            .await;
    }
}

impl StorageWriter for RustyWalletDatabase {
    async fn persist(&mut self) {
        self.db.flush().await;
    }

    async fn drop_unpersisted(&mut self) {
        unimplemented!("wallet does not need it")
    }
}

#[derive(Debug, Clone, thiserror::Error)]
pub enum WalletDbConnectError {
    #[error("Wallet database schema version is lower than expected.  expected schema version: {}, found: {}", expected, found)]
    SchemaVersionTooLow { found: u16, expected: u16 },
    #[error("Wallet database schema version is higher than expected.  It appears to come from a newer release of neptune-core.  expected schema version: {}, found: {}", expected, found)]
    SchemaVersionTooHigh { found: u16, expected: u16 },
    #[error("wallet db connect failed: {0}")]
    Failed(String),
}

// convert anyhow::Error to WalletDbConnectError::Failed.
// note that anyhow Error is not serializable.
impl From<anyhow::Error> for WalletDbConnectError {
    fn from(e: anyhow::Error) -> Self {
        Self::Failed(e.to_string())
    }
}

use twenty_first::prelude::Digest;

use super::expected_utxo::ExpectedUtxo;
use super::monitored_utxo::MonitoredUtxo;
use super::sent_transaction::SentTransaction;
use crate::application::database::storage::storage_schema::DbtSingleton;
use crate::application::database::storage::storage_schema::DbtVec;
use crate::application::database::storage::storage_schema::SimpleRustyStorage;
use crate::prelude::twenty_first;

/// defines the schema version of the wallet database.
///
/// The schema version is a simple integer that must be incremented each time
/// that an existing type that is stored in the DB gets changed.
///
/// note that this extends to types included by other types, eg `TxOutput`
/// because it is used by `SentTransaction` which is used in `WalletDbTables`
///
///  When such a change occurs, then a db-migration becomes necessary.  See
///  [migrate_db](super::migrate_db).
///
/// note: the very first schema version was 0, ie u16::default()
pub(super) const WALLET_DB_SCHEMA_VERSION: u16 = 1;

/// represents logical "tables" in the Wallet database as used by `DbtSchema`.
///
/// Schema Versioning and Migration:
///
/// there are two types of supported schema modifications:
///  1. a new field is added to this struct (at the end)
///  2. the type of an existing field is modified (including any sub-type)
///
///  type (1) does not require WALLET_DB_SCHEMA_VERSION to change, or a migration.
///  type (2) does require WALLET_BD_SCHEMA_VERSION to change, and a migration.
///
/// For migrations, see `migrate_db::migrate_db_impl`
///
/// Table Ordering: Important!
///
/// `DbtSchema` prefixes key values with the table order, which is
/// incremented as new_vec() and new_singleton() is called.
///
/// This means it is critical that these methods always be called
/// in the same order.  If not, older databases will not be loaded
/// correctly.
///
/// The fields of WalletDbTable are listed in order, and the
/// load_schema_in_order() method loads them in the same order.
///
/// Any new fields must be added at the end.
#[derive(Debug)]
pub(super) struct WalletDbTables {
    // list of utxos we have already received in a block
    // table number: 0
    pub(super) monitored_utxos: DbtVec<MonitoredUtxo>,

    // list of off-chain utxos we are expecting to receive in a future block
    // table number: 1
    pub(super) expected_utxos: DbtVec<ExpectedUtxo>,

    /// list of transactions sent by this wallet.
    // table number: 2
    pub(super) sent_transactions: DbtVec<SentTransaction>,

    // records which block the database is synced to
    // table number: 3
    pub(super) sync_label: DbtSingleton<Digest>,

    // counts the number of output UTXOs generated by this wallet
    // table number: 4
    pub(super) counter: DbtSingleton<u64>,

    // counts derived generation keys
    // The counter value represents derive index of next unused key.
    // table number: 5
    pub(super) generation_key_counter: DbtSingleton<u64>,

    // counts derived symmetric keys
    // The counter value represents derive index of next unused key.
    // table number: 6
    pub(super) symmetric_key_counter: DbtSingleton<u64>,

    #[allow(dead_code)]
    // table number: 7
    pub(super) schema_version: DbtSingleton<u16>,
}

impl WalletDbTables {
    /// loads fields in order.
    ///
    /// It is critical that this order not be changed.  Any new elements
    /// must be added at the end.
    ///
    /// See description of [WalletDbTables].
    pub(super) async fn load_schema_in_order(storage: &mut SimpleRustyStorage) -> WalletDbTables {
        let monitored_utxos = storage
            .schema
            .new_vec::<MonitoredUtxo>("monitored_utxos")
            .await;

        let expected_utxos = storage
            .schema
            .new_vec::<ExpectedUtxo>("expected_utxos")
            .await;

        let sent_transactions = storage
            .schema
            .new_vec::<SentTransaction>("sent_transactions")
            .await;

        let sync_label = storage.schema.new_singleton::<Digest>("sync_label").await;

        let counter = storage.schema.new_singleton::<u64>("counter").await;

        let generation_key_counter = storage
            .schema
            .new_singleton::<u64>("generation_key_counter")
            .await;
        let symmetric_key_counter = storage
            .schema
            .new_singleton::<u64>("symmetric_key_counter")
            .await;

        let schema_version = storage.schema.new_singleton::<u16>("schema_version").await;

        WalletDbTables {
            sync_label,
            monitored_utxos,
            expected_utxos,
            sent_transactions,
            counter,
            generation_key_counter,
            symmetric_key_counter,
            schema_version,
        }
    }

    pub(super) fn sent_transactions_table_count() -> u8 {
        2
    }
}

use serde::Deserialize;
use serde::Serialize;
use twenty_first::prelude::Digest;

use super::expected_utxo::ExpectedUtxo;
use super::monitored_utxo::MonitoredUtxo;
use super::sent_transaction::SentTransaction;
use crate::api::export::AdditionRecord;
use crate::application::database::storage::storage_schema::DbtMap;
use crate::application::database::storage::storage_schema::DbtSingleton;
use crate::application::database::storage::storage_schema::DbtVec;
use crate::application::database::storage::storage_schema::SimpleRustyStorage;
use crate::application::database::storage::storage_vec::Index;
use crate::prelude::twenty_first;
use crate::state::wallet::unlocked_utxo::UnlockedUtxo;

/// An ID for UTXOs that defines uniqueness of a UTXO even in the case of
/// reorganizations. In the case of reorganizations both the AOCL leaf index and
/// the addition record is required to identify a UTXO across multiple forks. We
/// do not use the block digest in which the UTXO was mined in this definition
//  since a reorganization that repeats some UTXOs at the same location in the
/// AOCL is not considered to introduce new UTXOs, rather the same UTXOs are
/// present, but they were just mined in different blocks.
///
/// From the perspective of the mutator set, two UTXOs with the same
/// [`StrongUtxoKey`] will always have the same lockscript and mutator set
/// membership proofs.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub(crate) struct StrongUtxoKey {
    addition_record: AdditionRecord,
    aocl_index: u64,
}

impl StrongUtxoKey {
    pub(crate) fn new(addition_record: AdditionRecord, aocl_index: u64) -> Self {
        Self {
            addition_record,
            aocl_index,
        }
    }
}

impl From<&UnlockedUtxo> for StrongUtxoKey {
    fn from(unlocked_utxo: &UnlockedUtxo) -> Self {
        Self::new(
            unlocked_utxo.addition_record(),
            unlocked_utxo.mutator_set_mp().aocl_leaf_index,
        )
    }
}

/// defines the schema version of the wallet database.
///
/// The schema version is a simple integer that must be incremented each time
/// that an existing type that is stored in the DB gets changed.
///
/// note that this extends to types included by other types, eg `TxOutput`
/// because it is used by `SentTransaction` which is used in `WalletDbTables`
///
///  When such a change occurs, then a db-migration becomes necessary.  See
///  [migrate_db](super::migrate_db).
///
/// note: the very first schema version was 0, ie u16::default()
pub(super) const WALLET_DB_SCHEMA_VERSION: u16 = 2;

/// represents logical "tables" in the Wallet database as used by `DbtSchema`.
///
/// Schema Versioning and Migration:
///
/// there are two types of supported schema modifications:
///  1. a new field is added to this struct (at the end)
///  2. the type of an existing field is modified (including any sub-type)
///
///  type (1) does not require WALLET_DB_SCHEMA_VERSION to change, or a migration.
///  type (2) does require WALLET_BD_SCHEMA_VERSION to change, and a migration.
///
/// For migrations, see `migrate_db::migrate_db_impl`
///
/// Table Ordering: Important!
///
/// `DbtSchema` prefixes key values with the table order, which is
/// incremented as new_vec() and new_singleton() is called.
///
/// This means it is critical that these methods always be called
/// in the same order.  If not, older databases will not be loaded
/// correctly.
///
/// The fields of WalletDbTable are listed in order, and the
/// load_schema_in_order() method loads them in the same order.
///
/// Any new fields must be added at the end.
#[derive(Debug)]
pub(super) struct WalletDbTables {
    // table number: 0
    /// Append-only list of utxos we have already received in a block.
    /// Each element in this list must be accompanied by an element in the
    /// value [`Self::strong_key_to_mutxo`] such that duplicate UTXOs are never
    /// added and this check can be performed fast. And it must be accompanied
    /// by an element in the [`Self::index_set_to_mutxo`] table for fast mapping
    /// of absolute index set to monitored UTXO, such that spent UTXOs can
    /// quickly be identified.
    pub(super) monitored_utxos: DbtVec<MonitoredUtxo>,

    /// list of off-chain utxos we are expecting to receive in a future block.
    // table number: 1
    ///
    /// Length must match [`Self::addition_record_to_expected_utxo`].
    pub(super) expected_utxos: DbtVec<ExpectedUtxo>,

    /// list of transactions sent by this wallet.
    // table number: 2
    pub(super) sent_transactions: DbtVec<SentTransaction>,

    /// records which block the database is synced to
    // table number: 3
    pub(super) sync_label: DbtSingleton<Digest>,

    // counts the number of output UTXOs generated by this wallet
    // table number: 4
    pub(super) counter: DbtSingleton<u64>,

    // counts derived generation keys
    // The counter value represents derive index of next unused key.
    // table number: 5
    pub(super) generation_key_counter: DbtSingleton<u64>,

    // counts derived symmetric keys
    // The counter value represents derive index of next unused key.
    // table number: 6
    pub(super) symmetric_key_counter: DbtSingleton<u64>,

    #[allow(dead_code)]
    // table number: 7
    pub(super) schema_version: DbtSingleton<u16>,

    /// table numbers: 8 + 9
    /// Mapping from [`StrongUtxoKey`] to index into list of
    /// [`Self::monitored_utxos`]. A [`StrongUtxoKey`] uniquely identified a
    /// UTXO, in a way that neither an [`AdditionRecord`] nor an AOCL leaf index
    /// alone do, since two UTXOs in the mutator set can have the same addition
    /// records and in the case of reorganizations, two different UTXOs can also
    /// have the same AOCL leaf index.
    ///
    /// This mapping ensures that the same UTXO is never counted twice by the
    /// wallet.
    ///
    /// Each `monitored_utxo` *must* be represented by exactly one entry in this
    /// map.
    pub(super) strong_key_to_mutxo: DbtMap<StrongUtxoKey, Index>,

    /// table numbers 10 + 11
    /// Mapping from hash(absolute_indices) to index into list of
    /// `monitored_utxo` for UTXOs managed by this wallet.
    ///
    /// Each `monitored_utxo` *must* be represented as an element in this map.
    pub(super) index_set_to_mutxo: DbtMap<Digest, Index>,

    /// table numbers 12 + 13
    /// Mapping from [`AdditionRecord`] to [`ExpectedUtxo`], for fast lookup of
    /// [`ExpectedUtxo`].
    ///
    /// Length must match [`Self::expected_utxos`].
    pub(super) addition_record_to_expected_utxo: DbtMap<AdditionRecord, Index>,
}

impl WalletDbTables {
    /// loads fields in order.
    ///
    /// It is critical that this order not be changed.  Any new elements
    /// must be added at the end.
    ///
    /// See description of [WalletDbTables].
    pub(super) async fn load_schema_in_order(storage: &mut SimpleRustyStorage) -> WalletDbTables {
        let monitored_utxos = storage
            .schema
            .new_vec::<MonitoredUtxo>("monitored_utxos")
            .await;

        let expected_utxos = storage
            .schema
            .new_vec::<ExpectedUtxo>("expected_utxos")
            .await;

        let sent_transactions = storage
            .schema
            .new_vec::<SentTransaction>("sent_transactions")
            .await;

        let sync_label = storage.schema.new_singleton::<Digest>("sync_label").await;

        let counter = storage.schema.new_singleton::<u64>("counter").await;

        let generation_key_counter = storage
            .schema
            .new_singleton::<u64>("generation_key_counter")
            .await;
        let symmetric_key_counter = storage
            .schema
            .new_singleton::<u64>("symmetric_key_counter")
            .await;

        let schema_version = storage.schema.new_singleton::<u16>("schema_version").await;

        let strong_key_to_mutxo = storage.schema.new_map("strong_key_to_mutxo").await;

        let index_set_to_mutxo = storage.schema.new_map("absolute_index_set_to_mutxo").await;

        let addition_record_to_expected_utxo = storage
            .schema
            .new_map("addition_record_to_expected_utxo")
            .await;

        WalletDbTables {
            sync_label,
            monitored_utxos,
            expected_utxos,
            sent_transactions,
            counter,
            generation_key_counter,
            symmetric_key_counter,
            schema_version,
            strong_key_to_mutxo,
            index_set_to_mutxo,
            addition_record_to_expected_utxo,
        }
    }

    pub(super) fn sent_transactions_table_count() -> u8 {
        2
    }

    pub(crate) fn monitored_utxos_table_count() -> u8 {
        0
    }
}

#[cfg(test)]
pub(crate) mod tests {
    use super::*;

    impl WalletDbTables {
        pub(crate) fn schema_version_table_count() -> u8 {
            7
        }

        pub(crate) fn sync_label_table_count() -> u8 {
            3
        }

        pub(crate) fn expected_utxo_table_count() -> u8 {
            1
        }
    }
}

use crate::application::loops::connect_to_peers::get_codec_rules;
use crate::protocol::peer::PeerMessage;

use futures::Sink;
use futures::SinkExt;
use futures::Stream;
use futures::TryStreamExt;
use libp2p::Stream as Libp2pStream;
use std::io;
use std::pin::Pin;
use tokio_util::codec::Framed;
use tokio_util::compat::FuturesAsyncReadCompatExt;

/// A transport-agnostic wrapper for peer communication.
///
/// `PeerStream` abstracts away the difference between a standard TCP connection
/// and a libp2p multiplexed stream. This allows the core Neptune logic to
/// operate on a unified interface regardless of how the connection was
/// established.
///
/// This trait is used to erase the complex, nested types generated by
/// `tokio_util::codec::Framed` and `futures::StreamExt` combinators. It
/// provides a unified type that satisfies the `S` bound in
/// `handle_peer_message<S>`, specifically requiring:
/// - Bidirectional communication ([`Sink`] + [`Stream`]).
/// - Serialization of [`PeerMessage`] using `io::Error` for transport failures.
/// - Thread-safety ([`Send`]) and stack-stability ([`Unpin`]) for asynchronous
///   execution.
pub(crate) trait PeerStream:
    Stream<Item = Result<PeerMessage, io::Error>> + Sink<PeerMessage, Error = io::Error> + Unpin + Send
{
}

/// Blanket implementation to facilitate automatic type conversion.
///
/// Any type `T`—typically a [`tokio_util::codec::Framed`] instance or a
/// pinned combinator—that fulfills the required networking and safety
/// bounds is automatically categorized as a [`PeerStream`].
///
/// This eliminates the need to manually implement [`PeerStream`] for every
/// specific combination of wrappers (e.g., compatibility layers,
/// error-mappers, and codec-framers) used in the network stack.
impl<T> PeerStream for T where
    T: Stream<Item = Result<PeerMessage, io::Error>>
        + Sink<PeerMessage, Error = io::Error>
        + Unpin
        + Send
{
}

/// Adapts a raw [`libp2p::Stream`] into a type-erased [`PeerStream`].
///
/// This function uses *type erasure* via `Box<dyn PeerStream>`. In Rust,
/// complex chains of stream combinators (like `Framed`, `AndThen`, and
/// `Compat`) create deeply nested types that are difficult to name and
/// maintain. Type erasure  "erases" these specific, concrete types and hides
/// them behind a single trait interface ([`PeerStream`]).
///
/// This allows the consensus layer to interact with the stream without needing
/// to know the internal details of the libp2p stack or the specific wrappers
/// used for IO compatibility.
///
/// ### Transformation Steps
///
/// 1. **IO Compatibility**: Bridges `futures::io` ---> `tokio::io` using
///    `.compat()`.
/// 2. **Framing**: Applies length-delimited prefixing via [`get_codec_rules`].
/// 3. **Serialization**: Chains [`serde_json`] logic to transform raw bytes
///    into [`PeerMessage`] enums.
///
/// The resulting stream is pinned and boxed to satisfy the `Unpin` and `Send`
/// requirements of the peer message handling loops.
pub(crate) fn bridge_libp2p_stream(raw_stream: Libp2pStream) -> Pin<Box<dyn PeerStream>> {
    let tokio_compat_stream = raw_stream.compat();
    let framed_bytes = Framed::new(tokio_compat_stream, get_codec_rules());

    // By calling .sink_err_into() and .err_into(), we normalize the error types.
    // By using the combinators carefully, we build the final type.
    let stream = framed_bytes
        .sink_err_into::<io::Error>()
        .err_into::<io::Error>()
        // The .with and .and_then blocks are what caused the Unpin error.
        // We ensure the resulting wrapper is boxed if necessary.
        .with(|msg: PeerMessage| {
            let res = serde_json::to_vec(&msg)
                .map(bytes::Bytes::from)
                .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e));
            futures::future::ready(res)
        })
        .and_then(|bytes| {
            let res = serde_json::from_slice::<PeerMessage>(&bytes)
                .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e));
            futures::future::ready(res)
        });

    Box::pin(stream)
}

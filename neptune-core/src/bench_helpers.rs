use std::env;
use std::path::Path;
use std::path::PathBuf;

use anyhow::Result;
use itertools::Itertools;
use num_traits::CheckedSub;
use rand::distr::Alphanumeric;
use rand::distr::SampleString;
use rand::Rng;
use tokio::sync::mpsc;

use crate::api::export::GlobalStateLock;
use crate::api::export::NativeCurrencyAmount;
use crate::api::export::NeptuneProof;
use crate::api::export::Network;
use crate::api::export::ReceivingAddress;
use crate::api::export::Timestamp;
use crate::api::export::Transaction;
use crate::api::export::TransactionDetails;
use crate::api::export::TransactionProof;
use crate::api::export::TxOutputList;
use crate::application::config::cli_args;
use crate::application::config::data_directory::DataDirectory;
use crate::application::loops::channel::RPCServerToMain;
use crate::protocol::consensus::block::block_transaction::BlockTransaction;
use crate::protocol::consensus::block::validity::block_primitive_witness::BlockPrimitiveWitness;
use crate::protocol::consensus::block::validity::block_proof_witness::BlockProofWitness;
use crate::protocol::consensus::block::Block;
use crate::protocol::consensus::block::BlockProof;
use crate::protocol::consensus::transaction::primitive_witness::PrimitiveWitness;
use crate::protocol::consensus::transaction::transaction_kernel::TransactionKernel;
use crate::protocol::consensus::transaction::transaction_kernel::TransactionKernelModifier;
use crate::state::wallet::expected_utxo::ExpectedUtxo;
use crate::state::wallet::expected_utxo::UtxoNotifier;
use crate::state::wallet::transaction_output::TxOutput;
use crate::state::wallet::utxo_notification::UtxoNotificationMedium;
use crate::state::wallet::wallet_configuration::WalletConfiguration;
use crate::state::wallet::wallet_entropy::WalletEntropy;
use crate::state::wallet::wallet_state::WalletState;
use crate::state::GlobalState;
use crate::util_types::mutator_set::removal_record::removal_record_list::RemovalRecordList;
use crate::RPC_CHANNEL_CAPACITY;

/// Data directory used for files generated by benchmarks. All contents of this
/// directory can safely be deleted after each benchmark run.
pub fn benchmark_data_directory(network: Network) -> Result<DataDirectory> {
    let mut rng = rand::rng();
    let user = env::var("USER").unwrap_or_else(|_| "default".to_string());
    let tmp_root: PathBuf = env::temp_dir()
        .join(format!("neptune-benchmark-runs-{}", user))
        .join(Path::new(&Alphanumeric.sample_string(&mut rng, 16)));

    DataDirectory::get(Some(tmp_root), network)
}

/// Initialize a global state with a non-zero balance at genesis.
pub async fn devops_global_state_genesis(cli_args: cli_args::Args) -> GlobalStateLock {
    let data_directory = benchmark_data_directory(cli_args.network).unwrap();
    let genesis = Block::genesis(cli_args.network);
    let wallet_state = devops_wallet_state_genesis(cli_args.network).await;
    let gs =
        GlobalState::try_new_with_wallet_state(data_directory, genesis, cli_args, wallet_state)
            .await
            .unwrap();
    let (rpc_server_to_main_tx, _rpc_server_to_main_rx) =
        mpsc::channel::<RPCServerToMain>(RPC_CHANNEL_CAPACITY);
    GlobalStateLock::from_global_state(gs, rpc_server_to_main_tx)
}

/// Wallet state synced to the genesis block for the specified network.
pub async fn devops_wallet_state_genesis(network: Network) -> WalletState {
    let data_directory = benchmark_data_directory(network).unwrap();
    DataDirectory::create_dir_if_not_exists(&data_directory.root_dir_path())
        .await
        .unwrap();

    DataDirectory::create_dir_if_not_exists(&data_directory.wallet_directory_path())
        .await
        .unwrap();
    let cli_args = cli_args::Args {
        network,
        ..Default::default()
    };
    let configuration = WalletConfiguration::new(&data_directory).absorb_options(&cli_args);

    let genesis = Block::genesis(network);
    WalletState::try_new(configuration, WalletEntropy::devnet_wallet(), &genesis)
        .await
        .unwrap()
}

pub fn extract_expected_utxos<'a>(
    wallet_state: &WalletState,
    tx_outputs: impl Iterator<Item = &'a TxOutput>,
) -> Vec<ExpectedUtxo> {
    wallet_state.extract_expected_utxos(tx_outputs, UtxoNotifier::Myself)
}

pub fn next_block_empty(parent: &Block, timestamp: Timestamp, network: Network) -> Block {
    let msa = parent.mutator_set_accumulator_after().unwrap();
    let nop = TransactionDetails::nop(msa, timestamp, network);

    block_from_tx_kernel(parent, network, nop.transaction_kernel())
}

/// Sends the wallet's entire balance to the provided address. Divides the
/// transaction up into `N` outputs, guaranteeing that the entire available
/// balance is being spent. Also returns tx output list for potential conversion
/// to expected UTXOs.
pub async fn next_block_incoming_utxos(
    parent: &Block,
    recipient: ReceivingAddress,
    num_outputs: usize,
    sender: &GlobalState,
    timestamp: Timestamp,
    notification_medium: UtxoNotificationMedium,
) -> (Block, TxOutputList) {
    let one_nau = NativeCurrencyAmount::from_nau(1);

    let fee = one_nau;

    // create N outputs of 1 nau each

    let mut outputs = vec![(recipient.clone(), one_nau); num_outputs - 1];

    // calc remaining amount and add it to outputs
    let intermediate_spend = outputs
        .iter()
        .map(|(_, amt)| *amt)
        .sum::<NativeCurrencyAmount>()
        + fee;

    let msa = parent.mutator_set_accumulator_after().unwrap();
    let wallet_status = sender.get_wallet_status_for_tip().await;
    let available_balance =
        wallet_status.confirmed_available_balance(parent.header().height, timestamp);
    let change_amt = available_balance.checked_sub(&intermediate_spend).unwrap();

    outputs.push((recipient.clone(), change_amt));

    let input_funds = sender.wallet_spendable_inputs_at_time(timestamp).await;

    let owned = sender
        .wallet_state
        .get_all_known_addressable_spending_keys()
        .map(|x| x.to_address())
        .any(|x| x == recipient);

    let mut rng = rand::rng();
    let outputs: TxOutputList = outputs
        .into_iter()
        .map(|(receiver, amount)| {
            TxOutput::native_currency(amount, rng.random(), receiver, notification_medium, owned)
        })
        .collect_vec()
        .into();

    let network = sender.cli().network;
    let tx_details = TransactionDetails::new_without_coinbase(
        input_funds,
        outputs.clone(),
        fee,
        timestamp,
        msa,
        network,
    );

    let kernel = PrimitiveWitness::from_transaction_details(&tx_details).kernel;
    let block = block_from_tx_kernel(parent, network, kernel);

    (block, outputs)
}

fn block_from_tx_kernel(parent: &Block, network: Network, txkernel: TransactionKernel) -> Block {
    let packed = RemovalRecordList::pack(txkernel.inputs.clone());
    let kernel = TransactionKernelModifier::default()
        .merge_bit(true)
        .inputs(packed)
        .modify(txkernel);
    let tx = Transaction {
        kernel,
        proof: TransactionProof::SingleProof(NeptuneProof::invalid()),
    };
    let tx: BlockTransaction = tx.try_into().unwrap();
    let timestamp = tx.kernel.timestamp;
    let block_primitive_witness = BlockPrimitiveWitness::new(parent.to_owned(), tx, network);
    let body = block_primitive_witness.body().to_owned();
    let header = block_primitive_witness.header(timestamp, network.target_block_interval());
    let (appendix, proof) = {
        let block_proof_witness = BlockProofWitness::produce(block_primitive_witness);
        let appendix = block_proof_witness.appendix();
        let invalid_proof = NeptuneProof::invalid();
        (appendix, BlockProof::SingleProof(invalid_proof))
    };

    Block::new(header, body, appendix, proof)
}
